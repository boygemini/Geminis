module.exports = "\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/primitives/url.js\nvar url_exports = {};\n__export(url_exports, {\n  URLPattern: () => me\n});\nmodule.exports = __toCommonJS(url_exports);\n\n// ../../node_modules/.pnpm/urlpattern-polyfill@9.0.0/node_modules/urlpattern-polyfill/dist/urlpattern.js\nvar k = /* @__PURE__ */ __name(class {\n  type = 3;\n  name = \"\";\n  prefix = \"\";\n  value = \"\";\n  suffix = \"\";\n  modifier = 3;\n  constructor(t, r, n, o, c, l) {\n    this.type = t, this.name = r, this.prefix = n, this.value = o, this.suffix = c, this.modifier = l;\n  }\n  hasCustomName() {\n    return this.name !== \"\" && typeof this.name != \"number\";\n  }\n}, \"k\");\nvar Pe = /[$_\\p{ID_Start}]/u;\nvar Se = /[$_\\u200C\\u200D\\p{ID_Continue}]/u;\nvar M = \".*\";\nfunction ke(e, t) {\n  return (t ? /^[\\x00-\\xFF]*$/ : /^[\\x00-\\x7F]*$/).test(e);\n}\n__name(ke, \"ke\");\nfunction v(e, t = false) {\n  let r = [], n = 0;\n  for (; n < e.length; ) {\n    let o = e[n], c = /* @__PURE__ */ __name(function(l) {\n      if (!t)\n        throw new TypeError(l);\n      r.push({ type: \"INVALID_CHAR\", index: n, value: e[n++] });\n    }, \"c\");\n    if (o === \"*\") {\n      r.push({ type: \"ASTERISK\", index: n, value: e[n++] });\n      continue;\n    }\n    if (o === \"+\" || o === \"?\") {\n      r.push({ type: \"OTHER_MODIFIER\", index: n, value: e[n++] });\n      continue;\n    }\n    if (o === \"\\\\\") {\n      r.push({ type: \"ESCAPED_CHAR\", index: n++, value: e[n++] });\n      continue;\n    }\n    if (o === \"{\") {\n      r.push({ type: \"OPEN\", index: n, value: e[n++] });\n      continue;\n    }\n    if (o === \"}\") {\n      r.push({ type: \"CLOSE\", index: n, value: e[n++] });\n      continue;\n    }\n    if (o === \":\") {\n      let l = \"\", s = n + 1;\n      for (; s < e.length; ) {\n        let i = e.substr(s, 1);\n        if (s === n + 1 && Pe.test(i) || s !== n + 1 && Se.test(i)) {\n          l += e[s++];\n          continue;\n        }\n        break;\n      }\n      if (!l) {\n        c(`Missing parameter name at ${n}`);\n        continue;\n      }\n      r.push({ type: \"NAME\", index: n, value: l }), n = s;\n      continue;\n    }\n    if (o === \"(\") {\n      let l = 1, s = \"\", i = n + 1, a = false;\n      if (e[i] === \"?\") {\n        c(`Pattern cannot start with \"?\" at ${i}`);\n        continue;\n      }\n      for (; i < e.length; ) {\n        if (!ke(e[i], false)) {\n          c(`Invalid character '${e[i]}' at ${i}.`), a = true;\n          break;\n        }\n        if (e[i] === \"\\\\\") {\n          s += e[i++] + e[i++];\n          continue;\n        }\n        if (e[i] === \")\") {\n          if (l--, l === 0) {\n            i++;\n            break;\n          }\n        } else if (e[i] === \"(\" && (l++, e[i + 1] !== \"?\")) {\n          c(`Capturing groups are not allowed at ${i}`), a = true;\n          break;\n        }\n        s += e[i++];\n      }\n      if (a)\n        continue;\n      if (l) {\n        c(`Unbalanced pattern at ${n}`);\n        continue;\n      }\n      if (!s) {\n        c(`Missing pattern at ${n}`);\n        continue;\n      }\n      r.push({ type: \"REGEX\", index: n, value: s }), n = i;\n      continue;\n    }\n    r.push({ type: \"CHAR\", index: n, value: e[n++] });\n  }\n  return r.push({ type: \"END\", index: n, value: \"\" }), r;\n}\n__name(v, \"v\");\nfunction D(e, t = {}) {\n  let r = v(e);\n  t.delimiter ?? (t.delimiter = \"/#?\"), t.prefixes ?? (t.prefixes = \"./\");\n  let n = `[^${x(t.delimiter)}]+?`, o = [], c = 0, l = 0, s = \"\", i = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ __name((f) => {\n    if (l < r.length && r[l].type === f)\n      return r[l++].value;\n  }, \"a\"), h = /* @__PURE__ */ __name(() => a(\"OTHER_MODIFIER\") ?? a(\"ASTERISK\"), \"h\"), p = /* @__PURE__ */ __name((f) => {\n    let u = a(f);\n    if (u !== void 0)\n      return u;\n    let { type: d, index: T } = r[l];\n    throw new TypeError(`Unexpected ${d} at ${T}, expected ${f}`);\n  }, \"p\"), O = /* @__PURE__ */ __name(() => {\n    let f = \"\", u;\n    for (; u = a(\"CHAR\") ?? a(\"ESCAPED_CHAR\"); )\n      f += u;\n    return f;\n  }, \"O\"), xe = /* @__PURE__ */ __name((f) => f, \"xe\"), L = t.encodePart || xe, I = \"\", H = /* @__PURE__ */ __name((f) => {\n    I += f;\n  }, \"H\"), $ = /* @__PURE__ */ __name(() => {\n    I.length && (o.push(new k(3, \"\", \"\", L(I), \"\", 3)), I = \"\");\n  }, \"$\"), G = /* @__PURE__ */ __name((f, u, d, T, Y) => {\n    let g = 3;\n    switch (Y) {\n      case \"?\":\n        g = 1;\n        break;\n      case \"*\":\n        g = 0;\n        break;\n      case \"+\":\n        g = 2;\n        break;\n    }\n    if (!u && !d && g === 3) {\n      H(f);\n      return;\n    }\n    if ($(), !u && !d) {\n      if (!f)\n        return;\n      o.push(new k(3, \"\", \"\", L(f), \"\", g));\n      return;\n    }\n    let m;\n    d ? d === \"*\" ? m = M : m = d : m = n;\n    let R = 2;\n    m === n ? (R = 1, m = \"\") : m === M && (R = 0, m = \"\");\n    let S;\n    if (u ? S = u : d && (S = c++), i.has(S))\n      throw new TypeError(`Duplicate name '${S}'.`);\n    i.add(S), o.push(new k(R, S, L(f), m, L(T), g));\n  }, \"G\");\n  for (; l < r.length; ) {\n    let f = a(\"CHAR\"), u = a(\"NAME\"), d = a(\"REGEX\");\n    if (!u && !d && (d = a(\"ASTERISK\")), u || d) {\n      let g = f ?? \"\";\n      t.prefixes.indexOf(g) === -1 && (H(g), g = \"\"), $();\n      let m = h();\n      G(g, u, d, \"\", m);\n      continue;\n    }\n    let T = f ?? a(\"ESCAPED_CHAR\");\n    if (T) {\n      H(T);\n      continue;\n    }\n    if (a(\"OPEN\")) {\n      let g = O(), m = a(\"NAME\"), R = a(\"REGEX\");\n      !m && !R && (R = a(\"ASTERISK\"));\n      let S = O();\n      p(\"CLOSE\");\n      let be = h();\n      G(g, m, R, S, be);\n      continue;\n    }\n    $(), p(\"END\");\n  }\n  return o;\n}\n__name(D, \"D\");\nfunction x(e) {\n  return e.replace(/([.+*?^${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n__name(x, \"x\");\nfunction X(e) {\n  return e && e.ignoreCase ? \"ui\" : \"u\";\n}\n__name(X, \"X\");\nfunction Z(e, t, r) {\n  return F(D(e, r), t, r);\n}\n__name(Z, \"Z\");\nfunction y(e) {\n  switch (e) {\n    case 0:\n      return \"*\";\n    case 1:\n      return \"?\";\n    case 2:\n      return \"+\";\n    case 3:\n      return \"\";\n  }\n}\n__name(y, \"y\");\nfunction F(e, t, r = {}) {\n  r.delimiter ?? (r.delimiter = \"/#?\"), r.prefixes ?? (r.prefixes = \"./\"), r.sensitive ?? (r.sensitive = false), r.strict ?? (r.strict = false), r.end ?? (r.end = true), r.start ?? (r.start = true), r.endsWith = \"\";\n  let n = r.start ? \"^\" : \"\";\n  for (let s of e) {\n    if (s.type === 3) {\n      s.modifier === 3 ? n += x(s.value) : n += `(?:${x(s.value)})${y(s.modifier)}`;\n      continue;\n    }\n    t && t.push(s.name);\n    let i = `[^${x(r.delimiter)}]+?`, a = s.value;\n    if (s.type === 1 ? a = i : s.type === 0 && (a = M), !s.prefix.length && !s.suffix.length) {\n      s.modifier === 3 || s.modifier === 1 ? n += `(${a})${y(s.modifier)}` : n += `((?:${a})${y(s.modifier)})`;\n      continue;\n    }\n    if (s.modifier === 3 || s.modifier === 1) {\n      n += `(?:${x(s.prefix)}(${a})${x(s.suffix)})`, n += y(s.modifier);\n      continue;\n    }\n    n += `(?:${x(s.prefix)}`, n += `((?:${a})(?:`, n += x(s.suffix), n += x(s.prefix), n += `(?:${a}))*)${x(s.suffix)})`, s.modifier === 0 && (n += \"?\");\n  }\n  let o = `[${x(r.endsWith)}]|$`, c = `[${x(r.delimiter)}]`;\n  if (r.end)\n    return r.strict || (n += `${c}?`), r.endsWith.length ? n += `(?=${o})` : n += \"$\", new RegExp(n, X(r));\n  r.strict || (n += `(?:${c}(?=${o}))?`);\n  let l = false;\n  if (e.length) {\n    let s = e[e.length - 1];\n    s.type === 3 && s.modifier === 3 && (l = r.delimiter.indexOf(s) > -1);\n  }\n  return l || (n += `(?=${c}|${o})`), new RegExp(n, X(r));\n}\n__name(F, \"F\");\nvar b = { delimiter: \"\", prefixes: \"\", sensitive: true, strict: true };\nvar B = { delimiter: \".\", prefixes: \"\", sensitive: true, strict: true };\nvar q = { delimiter: \"/\", prefixes: \"/\", sensitive: true, strict: true };\nfunction J(e, t) {\n  return e.length ? e[0] === \"/\" ? true : !t || e.length < 2 ? false : (e[0] == \"\\\\\" || e[0] == \"{\") && e[1] == \"/\" : false;\n}\n__name(J, \"J\");\nfunction Q(e, t) {\n  return e.startsWith(t) ? e.substring(t.length, e.length) : e;\n}\n__name(Q, \"Q\");\nfunction Ee(e, t) {\n  return e.endsWith(t) ? e.substr(0, e.length - t.length) : e;\n}\n__name(Ee, \"Ee\");\nfunction W(e) {\n  return !e || e.length < 2 ? false : e[0] === \"[\" || (e[0] === \"\\\\\" || e[0] === \"{\") && e[1] === \"[\";\n}\n__name(W, \"W\");\nvar ee = [\"ftp\", \"file\", \"http\", \"https\", \"ws\", \"wss\"];\nfunction N(e) {\n  if (!e)\n    return true;\n  for (let t of ee)\n    if (e.test(t))\n      return true;\n  return false;\n}\n__name(N, \"N\");\nfunction te(e, t) {\n  if (e = Q(e, \"#\"), t || e === \"\")\n    return e;\n  let r = new URL(\"https://example.com\");\n  return r.hash = e, r.hash ? r.hash.substring(1, r.hash.length) : \"\";\n}\n__name(te, \"te\");\nfunction re(e, t) {\n  if (e = Q(e, \"?\"), t || e === \"\")\n    return e;\n  let r = new URL(\"https://example.com\");\n  return r.search = e, r.search ? r.search.substring(1, r.search.length) : \"\";\n}\n__name(re, \"re\");\nfunction ne(e, t) {\n  return t || e === \"\" ? e : W(e) ? j(e) : z(e);\n}\n__name(ne, \"ne\");\nfunction se(e, t) {\n  if (t || e === \"\")\n    return e;\n  let r = new URL(\"https://example.com\");\n  return r.password = e, r.password;\n}\n__name(se, \"se\");\nfunction ie(e, t) {\n  if (t || e === \"\")\n    return e;\n  let r = new URL(\"https://example.com\");\n  return r.username = e, r.username;\n}\n__name(ie, \"ie\");\nfunction ae(e, t, r) {\n  if (r || e === \"\")\n    return e;\n  if (t && !ee.includes(t))\n    return new URL(`${t}:${e}`).pathname;\n  let n = e[0] == \"/\";\n  return e = new URL(n ? e : \"/-\" + e, \"https://example.com\").pathname, n || (e = e.substring(2, e.length)), e;\n}\n__name(ae, \"ae\");\nfunction oe(e, t, r) {\n  return _(t) === e && (e = \"\"), r || e === \"\" ? e : K(e);\n}\n__name(oe, \"oe\");\nfunction ce(e, t) {\n  return e = Ee(e, \":\"), t || e === \"\" ? e : A(e);\n}\n__name(ce, \"ce\");\nfunction _(e) {\n  switch (e) {\n    case \"ws\":\n    case \"http\":\n      return \"80\";\n    case \"wws\":\n    case \"https\":\n      return \"443\";\n    case \"ftp\":\n      return \"21\";\n    default:\n      return \"\";\n  }\n}\n__name(_, \"_\");\nfunction A(e) {\n  if (e === \"\")\n    return e;\n  if (/^[-+.A-Za-z0-9]*$/.test(e))\n    return e.toLowerCase();\n  throw new TypeError(`Invalid protocol '${e}'.`);\n}\n__name(A, \"A\");\nfunction le(e) {\n  if (e === \"\")\n    return e;\n  let t = new URL(\"https://example.com\");\n  return t.username = e, t.username;\n}\n__name(le, \"le\");\nfunction he(e) {\n  if (e === \"\")\n    return e;\n  let t = new URL(\"https://example.com\");\n  return t.password = e, t.password;\n}\n__name(he, \"he\");\nfunction z(e) {\n  if (e === \"\")\n    return e;\n  if (/[\\t\\n\\r #%/:<>?@[\\]^\\\\|]/g.test(e))\n    throw new TypeError(`Invalid hostname '${e}'`);\n  let t = new URL(\"https://example.com\");\n  return t.hostname = e, t.hostname;\n}\n__name(z, \"z\");\nfunction j(e) {\n  if (e === \"\")\n    return e;\n  if (/[^0-9a-fA-F[\\]:]/g.test(e))\n    throw new TypeError(`Invalid IPv6 hostname '${e}'`);\n  return e.toLowerCase();\n}\n__name(j, \"j\");\nfunction K(e) {\n  if (e === \"\" || /^[0-9]*$/.test(e) && parseInt(e) <= 65535)\n    return e;\n  throw new TypeError(`Invalid port '${e}'.`);\n}\n__name(K, \"K\");\nfunction fe(e) {\n  if (e === \"\")\n    return e;\n  let t = new URL(\"https://example.com\");\n  return t.pathname = e[0] !== \"/\" ? \"/-\" + e : e, e[0] !== \"/\" ? t.pathname.substring(2, t.pathname.length) : t.pathname;\n}\n__name(fe, \"fe\");\nfunction ue(e) {\n  return e === \"\" ? e : new URL(`data:${e}`).pathname;\n}\n__name(ue, \"ue\");\nfunction pe(e) {\n  if (e === \"\")\n    return e;\n  let t = new URL(\"https://example.com\");\n  return t.search = e, t.search.substring(1, t.search.length);\n}\n__name(pe, \"pe\");\nfunction de(e) {\n  if (e === \"\")\n    return e;\n  let t = new URL(\"https://example.com\");\n  return t.hash = e, t.hash.substring(1, t.hash.length);\n}\n__name(de, \"de\");\nvar U = /* @__PURE__ */ __name(class {\n  #i;\n  #n = [];\n  #t = {};\n  #e = 0;\n  #s = 1;\n  #u = 0;\n  #c = 0;\n  #p = 0;\n  #d = 0;\n  #g = false;\n  constructor(t) {\n    this.#i = t;\n  }\n  get result() {\n    return this.#t;\n  }\n  parse() {\n    for (this.#n = v(this.#i, true); this.#e < this.#n.length; this.#e += this.#s) {\n      if (this.#s = 1, this.#n[this.#e].type === \"END\") {\n        if (this.#c === 0) {\n          this.#P(), this.#l() ? this.#r(9, 1) : this.#h() ? (this.#r(8, 1), this.#t.hash = \"\") : (this.#r(7, 0), this.#t.search = \"\", this.#t.hash = \"\");\n          continue;\n        } else if (this.#c === 2) {\n          this.#f(5);\n          continue;\n        }\n        this.#r(10, 0);\n        break;\n      }\n      if (this.#p > 0)\n        if (this.#T())\n          this.#p -= 1;\n        else\n          continue;\n      if (this.#O()) {\n        this.#p += 1;\n        continue;\n      }\n      switch (this.#c) {\n        case 0:\n          this.#S() && (this.#t.username = \"\", this.#t.password = \"\", this.#t.hostname = \"\", this.#t.port = \"\", this.#t.pathname = \"\", this.#t.search = \"\", this.#t.hash = \"\", this.#f(1));\n          break;\n        case 1:\n          if (this.#S()) {\n            this.#C();\n            let t = 7, r = 1;\n            this.#g && (this.#t.pathname = \"/\"), this.#E() ? (t = 2, r = 3) : this.#g && (t = 2), this.#r(t, r);\n          }\n          break;\n        case 2:\n          this.#x() ? this.#f(3) : (this.#b() || this.#h() || this.#l()) && this.#f(5);\n          break;\n        case 3:\n          this.#R() ? this.#r(4, 1) : this.#x() && this.#r(5, 1);\n          break;\n        case 4:\n          this.#x() && this.#r(5, 1);\n          break;\n        case 5:\n          this.#A() ? this.#d += 1 : this.#w() && (this.#d -= 1), this.#y() && !this.#d ? this.#r(6, 1) : this.#b() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);\n          break;\n        case 6:\n          this.#b() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);\n          break;\n        case 7:\n          this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);\n          break;\n        case 8:\n          this.#l() && this.#r(9, 1);\n          break;\n        case 9:\n          break;\n        case 10:\n          break;\n      }\n    }\n  }\n  #r(t, r) {\n    switch (this.#c) {\n      case 0:\n        break;\n      case 1:\n        this.#t.protocol = this.#o();\n        break;\n      case 2:\n        break;\n      case 3:\n        this.#t.username = this.#o();\n        break;\n      case 4:\n        this.#t.password = this.#o();\n        break;\n      case 5:\n        this.#t.hostname = this.#o();\n        break;\n      case 6:\n        this.#t.port = this.#o();\n        break;\n      case 7:\n        this.#t.pathname = this.#o();\n        break;\n      case 8:\n        this.#t.search = this.#o();\n        break;\n      case 9:\n        this.#t.hash = this.#o();\n        break;\n      case 10:\n        break;\n    }\n    this.#k(t, r);\n  }\n  #k(t, r) {\n    this.#c = t, this.#u = this.#e + r, this.#e += r, this.#s = 0;\n  }\n  #P() {\n    this.#e = this.#u, this.#s = 0;\n  }\n  #f(t) {\n    this.#P(), this.#c = t;\n  }\n  #m(t) {\n    return t < 0 && (t = this.#n.length - t), t < this.#n.length ? this.#n[t] : this.#n[this.#n.length - 1];\n  }\n  #a(t, r) {\n    let n = this.#m(t);\n    return n.value === r && (n.type === \"CHAR\" || n.type === \"ESCAPED_CHAR\" || n.type === \"INVALID_CHAR\");\n  }\n  #S() {\n    return this.#a(this.#e, \":\");\n  }\n  #E() {\n    return this.#a(this.#e + 1, \"/\") && this.#a(this.#e + 2, \"/\");\n  }\n  #x() {\n    return this.#a(this.#e, \"@\");\n  }\n  #R() {\n    return this.#a(this.#e, \":\");\n  }\n  #y() {\n    return this.#a(this.#e, \":\");\n  }\n  #b() {\n    return this.#a(this.#e, \"/\");\n  }\n  #h() {\n    if (this.#a(this.#e, \"?\"))\n      return true;\n    if (this.#n[this.#e].value !== \"?\")\n      return false;\n    let t = this.#m(this.#e - 1);\n    return t.type !== \"NAME\" && t.type !== \"REGEX\" && t.type !== \"CLOSE\" && t.type !== \"ASTERISK\";\n  }\n  #l() {\n    return this.#a(this.#e, \"#\");\n  }\n  #O() {\n    return this.#n[this.#e].type == \"OPEN\";\n  }\n  #T() {\n    return this.#n[this.#e].type == \"CLOSE\";\n  }\n  #A() {\n    return this.#a(this.#e, \"[\");\n  }\n  #w() {\n    return this.#a(this.#e, \"]\");\n  }\n  #o() {\n    let t = this.#n[this.#e], r = this.#m(this.#u).index;\n    return this.#i.substring(r, t.index);\n  }\n  #C() {\n    let t = {};\n    Object.assign(t, b), t.encodePart = A;\n    let r = Z(this.#o(), void 0, t);\n    this.#g = N(r);\n  }\n}, \"U\");\nvar V = [\"protocol\", \"username\", \"password\", \"hostname\", \"port\", \"pathname\", \"search\", \"hash\"];\nvar E = \"*\";\nfunction ge(e, t) {\n  if (typeof e != \"string\")\n    throw new TypeError(\"parameter 1 is not of type 'string'.\");\n  let r = new URL(e, t);\n  return { protocol: r.protocol.substring(0, r.protocol.length - 1), username: r.username, password: r.password, hostname: r.hostname, port: r.port, pathname: r.pathname, search: r.search !== \"\" ? r.search.substring(1, r.search.length) : void 0, hash: r.hash !== \"\" ? r.hash.substring(1, r.hash.length) : void 0 };\n}\n__name(ge, \"ge\");\nfunction P(e, t) {\n  return t ? C(e) : e;\n}\n__name(P, \"P\");\nfunction w(e, t, r) {\n  let n;\n  if (typeof t.baseURL == \"string\")\n    try {\n      n = new URL(t.baseURL), e.protocol = P(n.protocol.substring(0, n.protocol.length - 1), r), e.username = P(n.username, r), e.password = P(n.password, r), e.hostname = P(n.hostname, r), e.port = P(n.port, r), e.pathname = P(n.pathname, r), e.search = P(n.search.substring(1, n.search.length), r), e.hash = P(n.hash.substring(1, n.hash.length), r);\n    } catch {\n      throw new TypeError(`invalid baseURL '${t.baseURL}'.`);\n    }\n  if (typeof t.protocol == \"string\" && (e.protocol = ce(t.protocol, r)), typeof t.username == \"string\" && (e.username = ie(t.username, r)), typeof t.password == \"string\" && (e.password = se(t.password, r)), typeof t.hostname == \"string\" && (e.hostname = ne(t.hostname, r)), typeof t.port == \"string\" && (e.port = oe(t.port, e.protocol, r)), typeof t.pathname == \"string\") {\n    if (e.pathname = t.pathname, n && !J(e.pathname, r)) {\n      let o = n.pathname.lastIndexOf(\"/\");\n      o >= 0 && (e.pathname = P(n.pathname.substring(0, o + 1), r) + e.pathname);\n    }\n    e.pathname = ae(e.pathname, e.protocol, r);\n  }\n  return typeof t.search == \"string\" && (e.search = re(t.search, r)), typeof t.hash == \"string\" && (e.hash = te(t.hash, r)), e;\n}\n__name(w, \"w\");\nfunction C(e) {\n  return e.replace(/([+*?:{}()\\\\])/g, \"\\\\$1\");\n}\n__name(C, \"C\");\nfunction Re(e) {\n  return e.replace(/([.+*?^${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n__name(Re, \"Re\");\nfunction ye(e, t) {\n  t.delimiter ?? (t.delimiter = \"/#?\"), t.prefixes ?? (t.prefixes = \"./\"), t.sensitive ?? (t.sensitive = false), t.strict ?? (t.strict = false), t.end ?? (t.end = true), t.start ?? (t.start = true), t.endsWith = \"\";\n  let r = \".*\", n = `[^${Re(t.delimiter)}]+?`, o = /[$_\\u200C\\u200D\\p{ID_Continue}]/u, c = \"\";\n  for (let l = 0; l < e.length; ++l) {\n    let s = e[l];\n    if (s.type === 3) {\n      if (s.modifier === 3) {\n        c += C(s.value);\n        continue;\n      }\n      c += `{${C(s.value)}}${y(s.modifier)}`;\n      continue;\n    }\n    let i = s.hasCustomName(), a = !!s.suffix.length || !!s.prefix.length && (s.prefix.length !== 1 || !t.prefixes.includes(s.prefix)), h = l > 0 ? e[l - 1] : null, p = l < e.length - 1 ? e[l + 1] : null;\n    if (!a && i && s.type === 1 && s.modifier === 3 && p && !p.prefix.length && !p.suffix.length)\n      if (p.type === 3) {\n        let O = p.value.length > 0 ? p.value[0] : \"\";\n        a = o.test(O);\n      } else\n        a = !p.hasCustomName();\n    if (!a && !s.prefix.length && h && h.type === 3) {\n      let O = h.value[h.value.length - 1];\n      a = t.prefixes.includes(O);\n    }\n    a && (c += \"{\"), c += C(s.prefix), i && (c += `:${s.name}`), s.type === 2 ? c += `(${s.value})` : s.type === 1 ? i || (c += `(${n})`) : s.type === 0 && (!i && (!h || h.type === 3 || h.modifier !== 3 || a || s.prefix !== \"\") ? c += \"*\" : c += `(${r})`), s.type === 1 && i && s.suffix.length && o.test(s.suffix[0]) && (c += \"\\\\\"), c += C(s.suffix), a && (c += \"}\"), s.modifier !== 3 && (c += y(s.modifier));\n  }\n  return c;\n}\n__name(ye, \"ye\");\nvar me = /* @__PURE__ */ __name(class {\n  #i;\n  #n = {};\n  #t = {};\n  #e = {};\n  #s = {};\n  constructor(t = {}, r, n) {\n    try {\n      let o;\n      if (typeof r == \"string\" ? o = r : n = r, typeof t == \"string\") {\n        let i = new U(t);\n        if (i.parse(), t = i.result, o === void 0 && typeof t.protocol != \"string\")\n          throw new TypeError(\"A base URL must be provided for a relative constructor string.\");\n        t.baseURL = o;\n      } else {\n        if (!t || typeof t != \"object\")\n          throw new TypeError(\"parameter 1 is not of type 'string' and cannot convert to dictionary.\");\n        if (o)\n          throw new TypeError(\"parameter 1 is not of type 'string'.\");\n      }\n      typeof n > \"u\" && (n = { ignoreCase: false });\n      let c = { ignoreCase: n.ignoreCase === true }, l = { pathname: E, protocol: E, username: E, password: E, hostname: E, port: E, search: E, hash: E };\n      this.#i = w(l, t, true), _(this.#i.protocol) === this.#i.port && (this.#i.port = \"\");\n      let s;\n      for (s of V) {\n        if (!(s in this.#i))\n          continue;\n        let i = {}, a = this.#i[s];\n        switch (this.#t[s] = [], s) {\n          case \"protocol\":\n            Object.assign(i, b), i.encodePart = A;\n            break;\n          case \"username\":\n            Object.assign(i, b), i.encodePart = le;\n            break;\n          case \"password\":\n            Object.assign(i, b), i.encodePart = he;\n            break;\n          case \"hostname\":\n            Object.assign(i, B), W(a) ? i.encodePart = j : i.encodePart = z;\n            break;\n          case \"port\":\n            Object.assign(i, b), i.encodePart = K;\n            break;\n          case \"pathname\":\n            N(this.#n.protocol) ? (Object.assign(i, q, c), i.encodePart = fe) : (Object.assign(i, b, c), i.encodePart = ue);\n            break;\n          case \"search\":\n            Object.assign(i, b, c), i.encodePart = pe;\n            break;\n          case \"hash\":\n            Object.assign(i, b, c), i.encodePart = de;\n            break;\n        }\n        try {\n          this.#s[s] = D(a, i), this.#n[s] = F(this.#s[s], this.#t[s], i), this.#e[s] = ye(this.#s[s], i);\n        } catch {\n          throw new TypeError(`invalid ${s} pattern '${this.#i[s]}'.`);\n        }\n      }\n    } catch (o) {\n      throw new TypeError(`Failed to construct 'URLPattern': ${o.message}`);\n    }\n  }\n  test(t = {}, r) {\n    let n = { pathname: \"\", protocol: \"\", username: \"\", password: \"\", hostname: \"\", port: \"\", search: \"\", hash: \"\" };\n    if (typeof t != \"string\" && r)\n      throw new TypeError(\"parameter 1 is not of type 'string'.\");\n    if (typeof t > \"u\")\n      return false;\n    try {\n      typeof t == \"object\" ? n = w(n, t, false) : n = w(n, ge(t, r), false);\n    } catch {\n      return false;\n    }\n    let o;\n    for (o of V)\n      if (!this.#n[o].exec(n[o]))\n        return false;\n    return true;\n  }\n  exec(t = {}, r) {\n    let n = { pathname: \"\", protocol: \"\", username: \"\", password: \"\", hostname: \"\", port: \"\", search: \"\", hash: \"\" };\n    if (typeof t != \"string\" && r)\n      throw new TypeError(\"parameter 1 is not of type 'string'.\");\n    if (typeof t > \"u\")\n      return;\n    try {\n      typeof t == \"object\" ? n = w(n, t, false) : n = w(n, ge(t, r), false);\n    } catch {\n      return null;\n    }\n    let o = {};\n    r ? o.inputs = [t, r] : o.inputs = [t];\n    let c;\n    for (c of V) {\n      let l = this.#n[c].exec(n[c]);\n      if (!l)\n        return null;\n      let s = {};\n      for (let [i, a] of this.#t[c].entries())\n        if (typeof a == \"string\" || typeof a == \"number\") {\n          let h = l[i + 1];\n          s[a] = h;\n        }\n      o[c] = { input: n[c] ?? \"\", groups: s };\n    }\n    return o;\n  }\n  static compareComponent(t, r, n) {\n    let o = /* @__PURE__ */ __name((i, a) => {\n      for (let h of [\"type\", \"modifier\", \"prefix\", \"value\", \"suffix\"]) {\n        if (i[h] < a[h])\n          return -1;\n        if (i[h] === a[h])\n          continue;\n        return 1;\n      }\n      return 0;\n    }, \"o\"), c = new k(3, \"\", \"\", \"\", \"\", 3), l = new k(0, \"\", \"\", \"\", \"\", 3), s = /* @__PURE__ */ __name((i, a) => {\n      let h = 0;\n      for (; h < Math.min(i.length, a.length); ++h) {\n        let p = o(i[h], a[h]);\n        if (p)\n          return p;\n      }\n      return i.length === a.length ? 0 : o(i[h] ?? c, a[h] ?? c);\n    }, \"s\");\n    return !r.#e[t] && !n.#e[t] ? 0 : r.#e[t] && !n.#e[t] ? s(r.#s[t], [l]) : !r.#e[t] && n.#e[t] ? s([l], n.#s[t]) : s(r.#s[t], n.#s[t]);\n  }\n  get protocol() {\n    return this.#e.protocol;\n  }\n  get username() {\n    return this.#e.username;\n  }\n  get password() {\n    return this.#e.password;\n  }\n  get hostname() {\n    return this.#e.hostname;\n  }\n  get port() {\n    return this.#e.port;\n  }\n  get pathname() {\n    return this.#e.pathname;\n  }\n  get search() {\n    return this.#e.search;\n  }\n  get hash() {\n    return this.#e.hash;\n  }\n}, \"me\");\n\n// ../../node_modules/.pnpm/urlpattern-polyfill@9.0.0/node_modules/urlpattern-polyfill/index.js\nif (!globalThis.URLPattern) {\n  globalThis.URLPattern = me;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  URLPattern\n});\n"